// Copyright (c) 2025 A Bit of Help, Inc.

package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"

	"github.com/abitofhelp/family-service/core/domain/entity"
	"github.com/abitofhelp/family-service/core/domain/valueobject"
	"github.com/abitofhelp/family-service/interface/adapters/graphql/generated"
	"github.com/abitofhelp/family-service/interface/adapters/graphql/model"
	"github.com/abitofhelp/servicelib/date"
	myerrors "github.com/abitofhelp/servicelib/errors"
	"go.uber.org/zap"
)

// ID is the resolver for the id field.
func (r *childResolver) ID(ctx context.Context, obj *entity.Child) (valueobject.ID, error) {
	return valueobject.ID(obj.ID()), nil
}

// BirthDate is the resolver for the birthDate field.
func (r *childResolver) BirthDate(ctx context.Context, obj *entity.Child) (string, error) {
	return date.FormatDate(obj.BirthDate()), nil
}

// DeathDate is the resolver for the deathDate field.
func (r *childResolver) DeathDate(ctx context.Context, obj *entity.Child) (*string, error) {
	if obj.DeathDate() == nil {
		return nil, nil
	}
	return date.FormatOptionalDate(obj.DeathDate()), nil
}

// CreateFamily is the resolver for the createFamily field.
func (r *mutationResolver) CreateFamily(ctx context.Context, input model.FamilyInput) (*model.Family, error) {
	// Convert parents
	parents := make([]entity.ParentDTO, 0, len(input.Parents))
	for _, p := range input.Parents {
		// Parse birth date
		birthDate, err := date.ParseDate(p.BirthDate)
		if err != nil {
			return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.ParseParentBirthDate")
		}

		// Parse death date if present
		deathDate, err := date.ParseOptionalDate(p.DeathDate)
		if err != nil {
			return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.ParseParentDeathDate")
		}

		parents = append(parents, entity.ParentDTO{
			ID:        p.ID.String(),
			FirstName: p.FirstName,
			LastName:  p.LastName,
			BirthDate: birthDate,
			DeathDate: deathDate,
		})
	}

	// Convert children
	children := make([]entity.ChildDTO, 0, len(input.Children))
	for _, c := range input.Children {
		// Parse birth date
		birthDate, err := date.ParseDate(c.BirthDate)
		if err != nil {
			return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.ParseChildBirthDate")
		}

		// Parse death date if present
		deathDate, err := date.ParseOptionalDate(c.DeathDate)
		if err != nil {
			return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.ParseChildDeathDate")
		}

		children = append(children, entity.ChildDTO{
			ID:        c.ID.String(),
			FirstName: c.FirstName,
			LastName:  c.LastName,
			BirthDate: birthDate,
			DeathDate: deathDate,
		})
	}

	// Create family DTO
	familyDTO := entity.FamilyDTO{
		ID:       input.ID.String(),
		Status:   input.Status.String(),
		Parents:  parents,
		Children: children,
	}

	// Call service
	resultDTO, err := r.familyService.CreateFamily(ctx, familyDTO)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.Service")
	}

	// Log successful creation
	r.Resolver.logger.Info(ctx, "Family created successfully",
		zap.String("family_id", resultDTO.ID),
		zap.String("status", resultDTO.Status),
		zap.Int("parents", len(resultDTO.Parents)),
		zap.Int("children", len(resultDTO.Children)))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// AddParent is the resolver for the addParent field.
func (r *mutationResolver) AddParent(ctx context.Context, familyID valueobject.ID, input model.ParentInput) (*model.Family, error) {
	// Parse birth date
	birthDate, err := date.ParseDate(input.BirthDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddParent.ParseBirthDate")
	}

	// Parse death date if present
	deathDate, err := date.ParseOptionalDate(input.DeathDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddParent.ParseDeathDate")
	}

	// Create parent DTO
	parentDTO := entity.ParentDTO{
		ID:        input.ID.String(),
		FirstName: input.FirstName,
		LastName:  input.LastName,
		BirthDate: birthDate,
		DeathDate: deathDate,
	}

	// Call service
	resultDTO, err := r.familyService.AddParent(ctx, familyID.String(), parentDTO)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddParent.Service")
	}

	// Log successful addition
	r.Resolver.logger.Info(ctx, "Parent added successfully",
		zap.String("family_id", familyID.String()),
		zap.String("parent_id", parentDTO.ID))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// AddChild is the resolver for the addChild field.
func (r *mutationResolver) AddChild(ctx context.Context, familyID valueobject.ID, input model.ChildInput) (*model.Family, error) {
	// Parse birth date
	birthDate, err := date.ParseDate(input.BirthDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddChild.ParseBirthDate")
	}

	// Parse death date if present
	deathDate, err := date.ParseOptionalDate(input.DeathDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddChild.ParseDeathDate")
	}

	// Create child DTO
	childDTO := entity.ChildDTO{
		ID:        input.ID.String(),
		FirstName: input.FirstName,
		LastName:  input.LastName,
		BirthDate: birthDate,
		DeathDate: deathDate,
	}

	// Call service
	resultDTO, err := r.familyService.AddChild(ctx, familyID.String(), childDTO)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddChild.Service")
	}

	// Log successful addition
	r.Resolver.logger.Info(ctx, "Child added successfully",
		zap.String("family_id", familyID.String()),
		zap.String("child_id", childDTO.ID))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// RemoveChild is the resolver for the removeChild field.
func (r *mutationResolver) RemoveChild(ctx context.Context, familyID valueobject.ID, childID valueobject.ID) (*model.Family, error) {
	// Call service
	resultDTO, err := r.familyService.RemoveChild(ctx, familyID.String(), childID.String())
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "RemoveChild.Service")
	}

	// Log successful removal
	r.Resolver.logger.Info(ctx, "Child removed successfully",
		zap.String("family_id", familyID.String()),
		zap.String("child_id", childID.String()))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// MarkParentDeceased is the resolver for the markParentDeceased field.
func (r *mutationResolver) MarkParentDeceased(ctx context.Context, familyID valueobject.ID, parentID valueobject.ID, deathDate string) (*model.Family, error) {
	// Parse death date
	parsedDeathDate, err := date.ParseDate(deathDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "MarkParentDeceased.ParseDeathDate")
	}

	// Call service
	resultDTO, err := r.familyService.MarkParentDeceased(ctx, familyID.String(), parentID.String(), parsedDeathDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "MarkParentDeceased.Service")
	}

	// Log successful operation
	r.Resolver.logger.Info(ctx, "Parent marked as deceased",
		zap.String("family_id", familyID.String()),
		zap.String("parent_id", parentID.String()),
		zap.Time("death_date", parsedDeathDate))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// Divorce is the resolver for the divorce field.
func (r *mutationResolver) Divorce(ctx context.Context, familyID valueobject.ID, custodialParentID valueobject.ID) (*model.Family, error) {
	// Call service
	resultDTO, err := r.familyService.Divorce(ctx, familyID.String(), custodialParentID.String())
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "Divorce.Service")
	}

	// Log successful operation
	r.Resolver.logger.Info(ctx, "Divorce processed successfully",
		zap.String("family_id", familyID.String()),
		zap.String("custodial_parent_id", custodialParentID.String()))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// ID is the resolver for the id field.
func (r *parentResolver) ID(ctx context.Context, obj *entity.Parent) (valueobject.ID, error) {
	return valueobject.ID(obj.ID()), nil
}

// BirthDate is the resolver for the birthDate field.
func (r *parentResolver) BirthDate(ctx context.Context, obj *entity.Parent) (string, error) {
	return date.FormatDate(obj.BirthDate()), nil
}

// DeathDate is the resolver for the deathDate field.
func (r *parentResolver) DeathDate(ctx context.Context, obj *entity.Parent) (*string, error) {
	if obj.DeathDate() == nil {
		return nil, nil
	}
	return date.FormatOptionalDate(obj.DeathDate()), nil
}

// GetFamily is the resolver for the getFamily field.
func (r *queryResolver) GetFamily(ctx context.Context, id valueobject.ID) (*model.Family, error) {
	// Call service
	resultDTO, err := r.familyService.GetFamily(ctx, id.String())
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "GetFamily.Service")
	}

	// Log successful retrieval
	r.Resolver.logger.Debug(ctx, "Family retrieved",
		zap.String("family_id", id.String()))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// GetAllFamilies is the resolver for the getAllFamilies field.
func (r *queryResolver) GetAllFamilies(ctx context.Context) ([]*model.Family, error) {
	// Call service
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "GetAllFamilies.Service")
	}

	// Log successful retrieval
	r.Resolver.logger.Debug(ctx, "All families retrieved",
		zap.Int("count", len(resultDTOs)))

	// Convert domain DTOs to GraphQL types
	families := make([]*model.Family, 0, len(resultDTOs))
	for _, dto := range resultDTOs {
		families = append(families, r.Resolver.dtoToModelFamily(*dto))
	}

	return families, nil
}

// FindFamiliesByParent is the resolver for the findFamiliesByParent field.
func (r *queryResolver) FindFamiliesByParent(ctx context.Context, parentID valueobject.ID) ([]*model.Family, error) {
	resultDTOs, err := r.familyService.FindFamiliesByParent(ctx, parentID.String())
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "FindFamiliesByParent.Service")
	}

	// Log successful retrieval
	r.Resolver.logger.Debug(ctx, "Families found by parent",
		zap.String("parent_id", parentID.String()),
		zap.Int("count", len(resultDTOs)))

	// Convert domain DTOs to GraphQL types
	families := make([]*model.Family, 0, len(resultDTOs))
	for _, dto := range resultDTOs {
		families = append(families, r.Resolver.dtoToModelFamily(*dto))
	}

	return families, nil
}

// FindFamilyByChild is the resolver for the findFamilyByChild field.
func (r *queryResolver) FindFamilyByChild(ctx context.Context, childID valueobject.ID) (*model.Family, error) {
	// This would require adding a new method to the FamilyService
	// For now, we'll return an error
	return nil, myerrors.NewApplicationError(nil, "not implemented", "NOT_IMPLEMENTED")
}

// Parents is the resolver for the parents field.
func (r *queryResolver) Parents(ctx context.Context) ([]*entity.Parent, error) {
	// Get all families
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "Parents.GetAllFamilies")
	}

	// Create a map to store unique parents by ID
	parentMap := make(map[string]*entity.Parent)

	// Extract all parents from all families
	for _, familyDTO := range resultDTOs {
		for _, parentDTO := range familyDTO.Parents {
			// Convert DTO to entity
			parent, err := entity.ParentFromDTO(parentDTO)
			if err != nil {
				r.Resolver.logger.Warn(ctx, "Failed to convert parent DTO to entity",
					zap.String("parent_id", parentDTO.ID),
					zap.Error(err))
				continue
			}
			// Store in map to ensure uniqueness
			parentMap[parent.ID()] = parent
		}
	}

	// Convert map to slice
	parents := make([]*entity.Parent, 0, len(parentMap))
	for _, parent := range parentMap {
		parents = append(parents, parent)
	}

	// Log successful retrieval
	r.Resolver.logger.Debug(ctx, "All parents retrieved",
		zap.Int("count", len(parents)))

	return parents, nil
}

// CountFamilies is the resolver for the countFamilies field.
func (r *queryResolver) CountFamilies(ctx context.Context) (int, error) {
	// Get all families
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return 0, r.Resolver.HandleError(ctx, err, "CountFamilies.GetAllFamilies")
	}

	count := len(resultDTOs)

	// Log successful count
	r.Resolver.logger.Debug(ctx, "Counted all families",
		zap.Int("count", count))

	return count, nil
}

// CountParents is the resolver for the countParents field.
func (r *queryResolver) CountParents(ctx context.Context) (int, error) {
	// Get all families
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return 0, r.Resolver.HandleError(ctx, err, "CountParents.GetAllFamilies")
	}

	// Create a map to store unique parents by ID
	parentMap := make(map[string]bool)

	// Extract all parents from all families
	for _, familyDTO := range resultDTOs {
		for _, parentDTO := range familyDTO.Parents {
			// Store in map to ensure uniqueness
			parentMap[parentDTO.ID] = true
		}
	}

	count := len(parentMap)

	// Log successful count
	r.Resolver.logger.Debug(ctx, "Counted all parents",
		zap.Int("count", count))

	return count, nil
}

// CountChildren is the resolver for the countChildren field.
func (r *queryResolver) CountChildren(ctx context.Context) (int, error) {
	// Get all families
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return 0, r.Resolver.HandleError(ctx, err, "CountChildren.GetAllFamilies")
	}

	// Create a map to store unique children by ID
	childMap := make(map[string]bool)

	// Extract all children from all families
	for _, familyDTO := range resultDTOs {
		for _, childDTO := range familyDTO.Children {
			// Store in map to ensure uniqueness
			childMap[childDTO.ID] = true
		}
	}

	count := len(childMap)

	// Log successful count
	r.Resolver.logger.Debug(ctx, "Counted all children",
		zap.Int("count", count))

	return count, nil
}

// Child returns generated.ChildResolver implementation.
func (r *Resolver) Child() generated.ChildResolver { return &childResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Parent returns generated.ParentResolver implementation.
func (r *Resolver) Parent() generated.ParentResolver { return &parentResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type childResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type parentResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// ParentCount is the resolver for the parentCount field.
func (r *queryResolver) ParentCount(ctx context.Context, obj *model.Family) (int, error) {
	return r.Resolver.GetParentCount(ctx, obj)
}

// ChildrenCount is the resolver for the childrenCount field.
func (r *queryResolver) ChildrenCount(ctx context.Context, obj *model.Family) (int, error) {
	return r.Resolver.GetChildrenCount(ctx, obj)
}
