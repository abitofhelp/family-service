package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"context"
	"time"

	"github.com/abitofhelp/family-service/core/domain/entity"
	"github.com/abitofhelp/family-service/core/domain/valueobject"
	"github.com/abitofhelp/family-service/interface/adapters/graphql/generated"
	"github.com/abitofhelp/family-service/interface/adapters/graphql/model"
	"github.com/abitofhelp/servicelib/date"
	myerrors "github.com/abitofhelp/servicelib/errors"
	"go.uber.org/zap"
)

// ParentCount is the resolver for the parentCount field.
func (r *familyResolver) ParentCount(ctx context.Context, obj *model.Family) (int, error) {
	return len(obj.Parents), nil
}

// ChildrenCount is the resolver for the childrenCount field.
func (r *familyResolver) ChildrenCount(ctx context.Context, obj *model.Family) (int, error) {
	return len(obj.Children), nil
}

// CreateFamily is the resolver for the createFamily field.
func (r *mutationResolver) CreateFamily(ctx context.Context, input model.FamilyInput) (*model.Family, error) {
	// Check if the user is authorized to create a family
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR"}, []string{"CREATE"}, "FAMILY", "CreateFamily"); err != nil {
		return nil, err
	}

	// Convert parents
	parents := make([]entity.ParentDTO, 0, len(input.Parents))
	for _, p := range input.Parents {
		// Parse birth date
		birthDate, err := date.ParseDate(p.BirthDate)
		if err != nil {
			return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.ParseParentBirthDate")
		}

		// Parse death date if present
		deathDate, err := date.ParseOptionalDate(p.DeathDate)
		if err != nil {
			return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.ParseParentDeathDate")
		}

		parents = append(parents, entity.ParentDTO{
			ID:        p.ID.String(),
			FirstName: p.FirstName,
			LastName:  p.LastName,
			BirthDate: birthDate,
			DeathDate: deathDate,
		})
	}

	// Convert children
	children := make([]entity.ChildDTO, 0, len(input.Children))
	for _, c := range input.Children {
		// Parse birth date
		birthDate, err := date.ParseDate(c.BirthDate)
		if err != nil {
			return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.ParseChildBirthDate")
		}

		// Parse death date if present
		deathDate, err := date.ParseOptionalDate(c.DeathDate)
		if err != nil {
			return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.ParseChildDeathDate")
		}

		children = append(children, entity.ChildDTO{
			ID:        c.ID.String(),
			FirstName: c.FirstName,
			LastName:  c.LastName,
			BirthDate: birthDate,
			DeathDate: deathDate,
		})
	}

	// Create family DTO
	familyDTO := entity.FamilyDTO{
		ID:       input.ID.String(),
		Status:   input.Status.String(),
		Parents:  parents,
		Children: children,
	}

	// Call service
	resultDTO, err := r.familyService.CreateFamily(ctx, familyDTO)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "CreateFamily.Service")
	}

	// Log successful creation
	r.Resolver.logger.Info(ctx, "Family created successfully",
		zap.String("family_id", resultDTO.ID),
		zap.String("status", resultDTO.Status),
		zap.Int("parents", len(resultDTO.Parents)),
		zap.Int("children", len(resultDTO.Children)))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// AddParent is the resolver for the addParent field.
func (r *mutationResolver) AddParent(ctx context.Context, familyID valueobject.ID, input model.ParentInput) (*model.Family, error) {
	// Check if the user is authorized to add a parent
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR"}, []string{"CREATE"}, "PARENT", "AddParent"); err != nil {
		return nil, err
	}

	// Parse birth date
	birthDate, err := date.ParseDate(input.BirthDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddParent.ParseBirthDate")
	}

	// Parse death date if present
	deathDate, err := date.ParseOptionalDate(input.DeathDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddParent.ParseDeathDate")
	}

	// Create parent DTO
	parentDTO := entity.ParentDTO{
		ID:        input.ID.String(),
		FirstName: input.FirstName,
		LastName:  input.LastName,
		BirthDate: birthDate,
		DeathDate: deathDate,
	}

	// Call service
	resultDTO, err := r.familyService.AddParent(ctx, familyID.String(), parentDTO)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddParent.Service")
	}

	// Log successful addition
	r.Resolver.logger.Info(ctx, "Parent added successfully",
		zap.String("family_id", familyID.String()),
		zap.String("parent_id", parentDTO.ID))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// AddChild is the resolver for the addChild field.
func (r *mutationResolver) AddChild(ctx context.Context, familyID valueobject.ID, input model.ChildInput) (*model.Family, error) {
	// Check if the user is authorized to add a child
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR"}, []string{"CREATE"}, "CHILD", "AddChild"); err != nil {
		return nil, err
	}

	// Parse birth date
	birthDate, err := date.ParseDate(input.BirthDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddChild.ParseBirthDate")
	}

	// Parse death date if present
	deathDate, err := date.ParseOptionalDate(input.DeathDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddChild.ParseDeathDate")
	}

	// Create child DTO
	childDTO := entity.ChildDTO{
		ID:        input.ID.String(),
		FirstName: input.FirstName,
		LastName:  input.LastName,
		BirthDate: birthDate,
		DeathDate: deathDate,
	}

	// Call service
	resultDTO, err := r.familyService.AddChild(ctx, familyID.String(), childDTO)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "AddChild.Service")
	}

	// Log successful addition
	r.Resolver.logger.Info(ctx, "Child added successfully",
		zap.String("family_id", familyID.String()),
		zap.String("child_id", childDTO.ID))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// RemoveChild is the resolver for the removeChild field.
func (r *mutationResolver) RemoveChild(ctx context.Context, familyID valueobject.ID, childID valueobject.ID) (*model.Family, error) {
	// Check if the user is authorized to remove a child
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR"}, []string{"DELETE"}, "CHILD", "RemoveChild"); err != nil {
		return nil, err
	}

	// Call service
	resultDTO, err := r.familyService.RemoveChild(ctx, familyID.String(), childID.String())
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "RemoveChild.Service")
	}

	// Log successful removal
	r.Resolver.logger.Info(ctx, "Child removed successfully",
		zap.String("family_id", familyID.String()),
		zap.String("child_id", childID.String()))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// MarkParentDeceased is the resolver for the markParentDeceased field.
func (r *mutationResolver) MarkParentDeceased(ctx context.Context, familyID valueobject.ID, parentID valueobject.ID, deathDate string) (*model.Family, error) {
	// Check if the user is authorized to mark a parent as deceased
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR"}, []string{"WRITE"}, "PARENT", "MarkParentDeceased"); err != nil {
		return nil, err
	}

	// Parse death date
	parsedDeathDate, err := date.ParseDate(deathDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "MarkParentDeceased.ParseDeathDate")
	}

	// Call service
	resultDTO, err := r.familyService.MarkParentDeceased(ctx, familyID.String(), parentID.String(), parsedDeathDate)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "MarkParentDeceased.Service")
	}

	// Log successful operation
	r.Resolver.logger.Info(ctx, "Parent marked as deceased",
		zap.String("family_id", familyID.String()),
		zap.String("parent_id", parentID.String()),
		zap.Time("death_date", parsedDeathDate))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// Divorce is the resolver for the divorce field.
func (r *mutationResolver) Divorce(ctx context.Context, familyID valueobject.ID, custodialParentID valueobject.ID) (*model.Family, error) {
	// Check if the user is authorized to process a divorce
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR"}, []string{"WRITE"}, "FAMILY", "Divorce"); err != nil {
		return nil, err
	}

	// Call service
	resultDTO, err := r.familyService.Divorce(ctx, familyID.String(), custodialParentID.String())
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "Divorce.Service")
	}

	// Log successful operation
	r.Resolver.logger.Info(ctx, "Divorce processed successfully",
		zap.String("family_id", familyID.String()),
		zap.String("custodial_parent_id", custodialParentID.String()))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// GetFamily is the resolver for the getFamily field.
func (r *queryResolver) GetFamily(ctx context.Context, id valueobject.ID) (*model.Family, error) {
	// Check if the user is authorized to get a family
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR", "VIEWER"}, []string{"READ"}, "FAMILY", "GetFamily"); err != nil {
		return nil, err
	}

	// Call service
	resultDTO, err := r.familyService.GetFamily(ctx, id.String())
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "GetFamily.Service")
	}

	// Log successful retrieval
	r.Resolver.logger.Debug(ctx, "Family retrieved",
		zap.String("family_id", id.String()))

	// Convert result back to model.Family
	return r.Resolver.dtoToModelFamily(*resultDTO), nil
}

// GetAllFamilies is the resolver for the getAllFamilies field.
func (r *queryResolver) GetAllFamilies(ctx context.Context) ([]*model.Family, error) {
	// Check if the user is authorized to get all families
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR", "VIEWER"}, []string{"READ"}, "FAMILY", "GetAllFamilies"); err != nil {
		return nil, err
	}

	// Call service
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "GetAllFamilies.Service")
	}

	// Log successful retrieval
	r.Resolver.logger.Debug(ctx, "All families retrieved",
		zap.Int("count", len(resultDTOs)))

	// Convert domain DTOs to GraphQL types
	families := make([]*model.Family, 0, len(resultDTOs))
	for _, dto := range resultDTOs {
		families = append(families, r.Resolver.dtoToModelFamily(*dto))
	}

	return families, nil
}

// FindFamiliesByParent is the resolver for the findFamiliesByParent field.
func (r *queryResolver) FindFamiliesByParent(ctx context.Context, parentID valueobject.ID) ([]*model.Family, error) {
	// Check if the user is authorized to find families by parent
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR", "VIEWER"}, []string{"READ"}, "PARENT", "FindFamiliesByParent"); err != nil {
		return nil, err
	}

	resultDTOs, err := r.familyService.FindFamiliesByParent(ctx, parentID.String())
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "FindFamiliesByParent.Service")
	}

	// Log successful retrieval
	r.Resolver.logger.Debug(ctx, "Families found by parent",
		zap.String("parent_id", parentID.String()),
		zap.Int("count", len(resultDTOs)))

	// Convert domain DTOs to GraphQL types
	families := make([]*model.Family, 0, len(resultDTOs))
	for _, dto := range resultDTOs {
		families = append(families, r.Resolver.dtoToModelFamily(*dto))
	}

	return families, nil
}

// FindFamilyByChild is the resolver for the findFamilyByChild field.
func (r *queryResolver) FindFamilyByChild(ctx context.Context, childID valueobject.ID) (*model.Family, error) {
	// Check if the user is authorized to find family by child
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR", "VIEWER"}, []string{"READ"}, "CHILD", "FindFamilyByChild"); err != nil {
		return nil, err
	}

	// This would require adding a new method to the FamilyService
	// For now, we'll return an error
	return nil, myerrors.NewApplicationError(nil, "not implemented", "NOT_IMPLEMENTED")
}

// Parents is the resolver for the parents field.
func (r *queryResolver) Parents(ctx context.Context) ([]*model.Parent, error) {
	// Check if the user is authorized to get all parents
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR", "VIEWER"}, []string{"READ"}, "PARENT", "Parents"); err != nil {
		return nil, err
	}

	// Get all families
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return nil, r.Resolver.HandleError(ctx, err, "Parents.GetAllFamilies")
	}

	// Create a map to store unique parents by ID
	parentMap := make(map[string]*entity.Parent)

	// Extract all parents from all families
	for _, familyDTO := range resultDTOs {
		for _, parentDTO := range familyDTO.Parents {
			// Convert DTO to entity
			parent, err := entity.ParentFromDTO(parentDTO)
			if err != nil {
				r.Resolver.logger.Warn(ctx, "Failed to convert parent DTO to entity",
					zap.String("parent_id", parentDTO.ID),
					zap.Error(err))
				continue
			}
			// Store in map to ensure uniqueness
			parentMap[parent.ID()] = parent
		}
	}

	// Convert entity parents to model parents
	modelParents := make([]*model.Parent, 0, len(parentMap))
	for _, parent := range parentMap {
		// Convert entity to model
		deathDate := parent.DeathDate()
		var deathDateStr *string
		if deathDate != nil {
			formatted := parent.DeathDate().Format(time.RFC3339)
			deathDateStr = &formatted
		}

		modelParent := &model.Parent{
			ID:        valueobject.ID(parent.ID()),
			FirstName: parent.FirstName(),
			LastName:  parent.LastName(),
			BirthDate: parent.BirthDate().Format(time.RFC3339),
			DeathDate: deathDateStr,
		}

		modelParents = append(modelParents, modelParent)
	}

	// Log successful retrieval
	r.Resolver.logger.Debug(ctx, "All parents retrieved",
		zap.Int("count", len(modelParents)))

	return modelParents, nil
}

// CountFamilies is the resolver for the countFamilies field.
func (r *queryResolver) CountFamilies(ctx context.Context) (int, error) {
	// Check if the user is authorized to count families
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR", "VIEWER"}, []string{"READ"}, "FAMILY", "CountFamilies"); err != nil {
		return 0, err
	}

	// Get all families
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return 0, r.Resolver.HandleError(ctx, err, "CountFamilies.GetAllFamilies")
	}

	count := len(resultDTOs)

	// Log successful count
	r.Resolver.logger.Debug(ctx, "Counted all families",
		zap.Int("count", count))

	return count, nil
}

// CountParents is the resolver for the countParents field.
func (r *queryResolver) CountParents(ctx context.Context) (int, error) {
	// Check if the user is authorized to count parents
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR", "VIEWER"}, []string{"READ"}, "PARENT", "CountParents"); err != nil {
		return 0, err
	}

	// Get all families
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return 0, r.Resolver.HandleError(ctx, err, "CountParents.GetAllFamilies")
	}

	// Create a map to store unique parents by ID
	parentMap := make(map[string]bool)

	// Extract all parents from all families
	for _, familyDTO := range resultDTOs {
		for _, parentDTO := range familyDTO.Parents {
			// Store in map to ensure uniqueness
			parentMap[parentDTO.ID] = true
		}
	}

	count := len(parentMap)

	// Log successful count
	r.Resolver.logger.Debug(ctx, "Counted all parents",
		zap.Int("count", count))

	return count, nil
}

// CountChildren is the resolver for the countChildren field.
func (r *queryResolver) CountChildren(ctx context.Context) (int, error) {
	// Check if the user is authorized to count children
	if err := r.Resolver.CheckAuthorization(ctx, []string{"ADMIN", "EDITOR", "VIEWER"}, []string{"READ"}, "CHILD", "CountChildren"); err != nil {
		return 0, err
	}

	// Get all families
	resultDTOs, err := r.familyService.GetAllFamilies(ctx)
	if err != nil {
		return 0, r.Resolver.HandleError(ctx, err, "CountChildren.GetAllFamilies")
	}

	// Create a map to store unique children by ID
	childMap := make(map[string]bool)

	// Extract all children from all families
	for _, familyDTO := range resultDTOs {
		for _, childDTO := range familyDTO.Children {
			// Store in map to ensure uniqueness
			childMap[childDTO.ID] = true
		}
	}

	count := len(childMap)

	// Log successful count
	r.Resolver.logger.Debug(ctx, "Counted all children",
		zap.Int("count", count))

	return count, nil
}

// Family returns generated.FamilyResolver implementation.
func (r *Resolver) Family() generated.FamilyResolver { return &familyResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type familyResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
